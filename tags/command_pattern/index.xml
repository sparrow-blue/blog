<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>command_pattern on Design and Implementation</title><link>https://sparrow-blue.github.io/blog/tags/command_pattern/</link><description>Recent content in command_pattern on Design and Implementation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 13 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://sparrow-blue.github.io/blog/tags/command_pattern/index.xml" rel="self" type="application/rss+xml"/><item><title>Command Pattern</title><link>https://sparrow-blue.github.io/blog/posts/design_pattern/command_pattern/</link><pubDate>Tue, 13 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/design_pattern/command_pattern/</guid><description>このエントリの目指すところ 以下の観点で調査/検討する． どのようなシーンで使えるのか なぜそのシーンで使えるのか 必要に応じてプログラムに起こす．</description><content>&lt;h2 id="このエントリの目指すところ">このエントリの目指すところ&lt;/h2>
&lt;p>以下の観点で調査/検討する．&lt;/p>
&lt;ol>
&lt;li>どのようなシーンで使えるのか&lt;/li>
&lt;li>なぜそのシーンで使えるのか&lt;/li>
&lt;/ol>
&lt;p>必要に応じてプログラムに起こす．&lt;/p>
&lt;h2 id="調査">調査&lt;/h2>
&lt;h3 id="語られる像">語られる像&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://ja.wikipedia.org/wiki/Command_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Wikipedia - Command パターン&lt;/a>
&lt;blockquote>
&lt;p>リクエストのために必要な手続きとデータをCommandオブジェクトとしてカプセル化した上で取り回し[1]、必要に応じてExecute（実行）するパターンである。オブジェクトであることを生かして命令のキューイングやロギング、Undo等が可能になり[2]、Executeを分離したことで手続きと実行を疎結合にできる。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>&lt;a href="https://www.techscore.com/tech/DesignPattern/Command">TECHSCORE - 22. Commandパターン&lt;/a>
&lt;blockquote>
&lt;p>あるオブジェクトに対して要求を送るということは、そのオブジェクトのメソッドを呼び出すことと同じです。 そして、メソッドにどのような引数を渡すか、ということによって要求の内容は表現されます。さまざまな要求を送ろうとすると、引数の数や種類を増やさなければなりませんが、 それには限界があります。そこで要求自体をオブジェクトにしてしまい、そのオブジェクトを引数に渡すようにします。それがCommandパターンです。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>&lt;a href="https://zenn.dev/morinokami/books/learning-patterns-1/viewer/command-pattern">フロントエンドのデザインパターン - コマンドパターン&lt;/a>
&lt;blockquote>
&lt;p>コマンドパターン (command pattern) を用いると、あるタスクを実行するオブジェクトと、そのメソッドを呼び出すオブジェクトを切り離すことができことができます。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>&lt;a href="https://www.itsenka.com/contents/development/designpattern/command.html">IT専科 - Command パターン&lt;/a>
&lt;blockquote>
&lt;p>「Command」という英単語は、「命令」を意味します。
このパターンでは、1つもしくは複数の命令を1つのオブジェクトで表現(命令の詳細処理をカプセル化)します。また、命令をオブジェクトとして管理するため、その命令の履歴管理、UNDO(取消し)機能の実装等が容易に行えます。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h3 id="整理">整理&lt;/h3>
&lt;ol>
&lt;li>Command Pattern の典型的な用例として Undo/Redo が挙げられる&lt;/li>
&lt;li>手続き一式を隠ぺいし，オブジェクトとして取り扱えるようにする&lt;/li>
&lt;li>手続きがオブジェクトとして扱われることで，キューイングや呼び出し履歴の記録が可能になる&lt;/li>
&lt;li>ある手続きを定義したとして，それを実行する責務と分離される&lt;/li>
&lt;/ol>
&lt;h3 id="疑問">疑問&lt;/h3>
&lt;ol>
&lt;li>Redo はともかく Undo をどのように実現するのか
&lt;ul>
&lt;li>Command に対する入力と出力を保持しておくということか&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="要点">要点&lt;/h2>
&lt;h2 id="検討">検討&lt;/h2>
&lt;h3 id="どのようなシーンで使えるのか">どのようなシーンで使えるのか&lt;/h3>
&lt;h3 id="なぜそのシーンで使えるのか">なぜそのシーンで使えるのか&lt;/h3>
&lt;h2 id="実例">実例&lt;/h2>
&lt;h3 id="設計">設計&lt;/h3>
&lt;h3 id="実装">実装&lt;/h3>
&lt;pre>&lt;code>#include &lt;algorithm>
#include &lt;iostream>
#include &lt;list>
#include &lt;memory>
#include &lt;queue>
#include &lt;sstream>
namespace DesignPattern {
namespace CommandPattern {
/**
* 描画される図形の抽象クラス
*/
class Diagram {
public:
Diagram() : height(0), width(0) {}
virtual ~Diagram() = 0;
int height;
int width;
std::string to_string() {
std::stringstream ss;
ss &lt;&lt; typeid(this).name() &lt;&lt; ": "
&lt;&lt; "(" &lt;&lt; this->height &lt;&lt; "," &lt;&lt; this->width &lt;&lt; ")";
return ss.str();
}
};
Diagram::~Diagram() {}
/**
* 図形が描画されるキャンバス
*/
class Canvas {
public:
void AddDiagram(std::shared_ptr&lt;Diagram> diagram) {
this->diagrams.push_back(diagram);
}
void dump() {
std::for_each(
this->diagrams.begin(), this->diagrams.end(),
[](auto diagram) { std::cout &lt;&lt; diagram->to_string() &lt;&lt; std::endl; });
}
private:
std::vector&lt;std::shared_ptr&lt;Diagram>> diagrams;
};
/**
* 線分を表現するクラス
*/
class Line : public Diagram {
public:
Line() { this->width = 10; }
};
/**
* 三角形を表現するクラス
*/
class Triangle : public Diagram {
public:
Triangle() {
this->width = 10;
this->height = 5;
}
};
/**
* コマンドの抽象クラス
*/
class Command {
public:
Command(std::shared_ptr&lt;DesignPattern::CommandPattern::Canvas> canvas_)
: canvas(canvas_) {}
virtual void Execute() = 0;
protected:
std::shared_ptr&lt;Canvas> canvas;
};
/*
* 線分の生成を担うコマンド
*/
class CreateLineDiagramCommand : public Command {
public:
CreateLineDiagramCommand(
std::shared_ptr&lt;DesignPattern::CommandPattern::Canvas> canvas_)
: Command(canvas_) {}
virtual void Execute() {
auto new_diagram = std::make_shared&lt;Line>();
this->canvas->AddDiagram(new_diagram);
}
};
/*
* 三角形の生成を担うコマンド
*/
class CreateTriangleDiagramCommand : public Command {
public:
CreateTriangleDiagramCommand(
std::shared_ptr&lt;DesignPattern::CommandPattern::Canvas> canvas_)
: Command(canvas_) {
auto new_diagram = std::make_shared&lt;Triangle>();
this->canvas->AddDiagram(new_diagram);
}
virtual void Execute() {}
};
/*
* 図形の移動を担うコマンド
*/
class MoveDiagramCommand : public Command {
public:
virtual void Execute() {}
};
/*
* 図形のリサイズを担うコマンド
*/
class ResizeDiagramCommand : public Command {
public:
virtual void Execute() {}
};
} // namespace CommandPattern
} // namespace DesignPattern
using namespace DesignPattern::CommandPattern;
int main() {
auto canvas = std::make_shared&lt;Canvas>();
auto execution_queue = std::queue&lt;std::shared_ptr&lt;Command>>();
auto execution_history = std::list&lt;std::shared_ptr&lt;Command>>();
std::cout &lt;&lt; "# initial state" &lt;&lt; std::endl;
canvas->dump();
execution_queue.push(std::make_shared&lt;CreateLineDiagramCommand>(canvas));
execution_queue.push(std::make_shared&lt;CreateTriangleDiagramCommand>(canvas));
while (execution_queue.size()) {
auto command = execution_queue.front();
command->Execute();
execution_history.push_back(command);
execution_queue.pop();
}
std::cout &lt;&lt; "# final state" &lt;&lt; std::endl;
canvas->dump();
}
&lt;/code>&lt;/pre>
&lt;h3 id="実行結果">実行結果&lt;/h3>
&lt;pre>&lt;code>$ clang++ command_pattern.cpp -o command_pattern.out
$ ./command_pattern.out
# initial state
# final state
PN13DesignPattern14CommandPattern7DiagramE: (5,10)
PN13DesignPattern14CommandPattern7DiagramE: (0,10)
&lt;/code>&lt;/pre></content></item></channel></rss>