<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Templata Method on Design and Implementation</title><link>https://sparrow-blue.github.io/blog/tags/templata-method/</link><description>Recent content in Templata Method on Design and Implementation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 24 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://sparrow-blue.github.io/blog/tags/templata-method/index.xml" rel="self" type="application/rss+xml"/><item><title>アルゴリズムのカプセル化 / Encapsulating Algorithm</title><link>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/08_encapsulating_algorithms/</link><pubDate>Sat, 24 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/08_encapsulating_algorithms/</guid><description>Template Method Pattern 同じような処理の流れを踏むクラスが複数あったとして，Template Method Pattern は処理の流れを抽象化する． 本文中では例として以下の 2 つのクラス</description><content>&lt;h2 id="template-method-pattern">Template Method Pattern&lt;/h2>
&lt;p>同じような処理の流れを踏むクラスが複数あったとして，Template Method Pattern は処理の流れを抽象化する．&lt;/p>
&lt;p>本文中では例として以下の 2 つのクラスを考えている．&lt;/p>
&lt;ol>
&lt;li>コーヒーを淹れる&lt;/li>
&lt;li>紅茶を淹れる&lt;/li>
&lt;/ol>
&lt;p>それぞれ，大枠として以下の 4 つのステップを踏むという点で共通している．&lt;/p>
&lt;ol>
&lt;li>お湯を沸かす&lt;/li>
&lt;li>コーヒー/紅茶を抽出する&lt;/li>
&lt;li>カップに注ぐ&lt;/li>
&lt;li>コンディメントを淹れる&lt;/li>
&lt;/ol>
&lt;p>Template Method Pattern はこの一連の手続きの流れ自体を抽象化する．&lt;/p>
&lt;h3 id="template-method-pattern-の定義">Template Method Pattern の定義&lt;/h3>
&lt;p>本書では以下のように Template Method Pttern を定義している．&lt;/p>
&lt;blockquote>
&lt;p>Template Method パターンは，メソッド内でアルゴリズムの骨組みを定義し，一部の手順をサブクラスに委ねる．Template Method は，アルゴリズムの構造を変えることなく，アルゴリズムのある手順をサブクラスに再定義させる．&lt;/p>
&lt;/blockquote>
&lt;h3 id="caffeinebeverage-の実装">CaffeineBeverage の実装&lt;/h3>
&lt;p>本文中にある例をベースに Template Method Pattern の例を示す．&lt;/p>
&lt;details open>
&lt;summary>head_first_design_patterns/encapsulating_algorithm/caffeine_beverage.cpp&lt;/summary>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">// Copyright (c) 2023, Kumazawa (sparrow-blue)
&lt;/span>&lt;span style="color:#75715e">// This source code is licensed under the BSD 3-Clause License.
&lt;/span>&lt;span style="color:#75715e">// See https://github.com/sparrow-blue/blog/blob/main/LICENSE for details.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">/// @brief 飲み物を淹れるカップを表現する
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Cup&lt;/span> {};
&lt;span style="color:#75715e">/// @brief カフェインを含む飲み物を表現する
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CaffeineBeverage&lt;/span> {
&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#75715e">/// @brief 抽象化された手続き
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> Cup PrepareRecipe() &lt;span style="color:#66d9ef">final&lt;/span> {
&lt;span style="color:#75715e">// この部分が Template Method であり，それぞれの処理自体は具象クラスの実装に任せる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>BoilWater();
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Brew();
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>PourInCup();
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>AddCondiments();
&lt;span style="color:#66d9ef">return&lt;/span> cup_;
}
&lt;span style="color:#66d9ef">protected&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#75715e">/// @brief カップ
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Cup cup_;
&lt;span style="color:#75715e">/// @brief お湯を沸かす
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">BoilWater&lt;/span>() {}
&lt;span style="color:#75715e">/// @brief 淹れる
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Brew&lt;/span>() {}
&lt;span style="color:#75715e">/// @brief カップにそそぐ
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">PourInCup&lt;/span>() {}
&lt;span style="color:#75715e">/// @brief ミルクやレモンなどを添加する
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddCondiments&lt;/span>() {}
};
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Coffee&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> CaffeineBeverage {
&lt;span style="color:#66d9ef">protected&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Brew() { &lt;span style="color:#75715e">/* コーヒーを淹れる */&lt;/span>
}
&lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddCondiments&lt;/span>() { &lt;span style="color:#75715e">/* ミルクを入れる */&lt;/span>
}
};
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Tea&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> CaffeineBeverage {
&lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Brew&lt;/span>() { &lt;span style="color:#75715e">/* 紅茶を淹れる */&lt;/span>
}
&lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddCondiments&lt;/span>() { &lt;span style="color:#75715e">/* レモンを入れる */&lt;/span>
}
};
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {}
&lt;/code>&lt;/pre>&lt;/div>
&lt;/details>
&lt;h3 id="ハリウッドの原則--hollywood-principle">ハリウッドの原則 / Hollywood Principle&lt;/h3>
&lt;blockquote>
&lt;p>ハリウッドの原則&lt;br>
こちらを呼び出すな．こちらから呼び出す．&lt;br>
(Don&amp;rsquo;t call up, we&amp;rsquo;ll call you.)&lt;/p>
&lt;/blockquote>
&lt;p>Object Oriented Design におけるハリウッドの原則は，コンポーネント (典型的にはオブジェクト) 間の依存 (参照) 関係にルールを持たせようとするものである．OSI Reference Model や TCP/IP Protocol Suite の概念が類するといえるだろう．つまり上位のレイヤは下位のレイヤに依存するが，下位のレイヤは上位のレイヤに依存しない関係である．&lt;/p>
&lt;p>Template Method Pattern の文脈でこの言葉が出てきたのは親クラスが呼び出し方を定義し，子クラスが呼び出される処理を実装する，という意味で子クラスはハリウッドの原則でいうところの呼び出される側に徹している，という意味合いであると思われる．&lt;/p>
&lt;p>高水準コンポーネントと低水準コンポーネントについては 4 章 (P.139) で説明されているので，引用しておく．&lt;/p>
&lt;blockquote>
&lt;p>「高水準」コンポーネントとは，他の「低水準」コンポーネントに対して定義された振る舞いを持つクラスのことです．&lt;/p>
&lt;/blockquote>
&lt;p>なお，ハリウッドの原則と依存関係反転の原則の関係性について述べられている (P.300) が，依存関係反転の原則については 4 章で説明されているとのことなので，ここでは言及しない．&lt;br>
// 章立ての順で読んでいないため，8 章についてのまとめを書いている今現在，また 4 章を読んでいない．&lt;/p>
&lt;h2 id="感想">感想&lt;/h2>
&lt;h3 id="abstract-method-と-hhok">Abstract Method と Hhok&lt;/h3>
&lt;p>本文中では Template Method Pattern の実現方法として抽象メソッドを具象クラスで実装する方式とフックするメソッドをオーバライドする方式の 2 種類を提示している．ただ，Temmplate Method Pattern の定義にもあるように Template Method Pattern の目的は「アルゴリズムの骨組みを定義」することにあると考える．&lt;/p>
&lt;h3 id="hollywood-principle-について">Hollywood Principle について&lt;/h3>
&lt;p>ハリウッドの原則について以下のように補足されている (P.298).&lt;/p>
&lt;blockquote>
&lt;p>ハリウッドの原則を使うと，低水準コンポーネントがそれ自体をシステムにフックすることはできますが，高水準コンポーネントが低水準コンポーネントがいつどのように必要になるかについて判断します．&lt;/p>
&lt;/blockquote>
&lt;p>個人的には (確かに親クラスと読んだりはするが) 基底クラスを高水準コンポーネントと呼び，派生クラスを低水準コンポーネントの呼ぶのは，なんとなく抵抗がある (派生クラスのほうがレイヤが上ではないか)．&lt;br>
// 確かに派生クラスが基底クラスに依存しているので，基底クラスが高水準コンポーネント (依存される側) で派生クラスが低水準コンポーネント (依存する側) である，と言っているというのはわかる．&lt;/p></content></item></channel></rss>