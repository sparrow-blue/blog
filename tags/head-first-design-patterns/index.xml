<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Head First Design Patterns on Design and Implementation</title><link>https://sparrow-blue.github.io/blog/tags/head-first-design-patterns/</link><description>Recent content in Head First Design Patterns on Design and Implementation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 24 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://sparrow-blue.github.io/blog/tags/head-first-design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Head Firstデザインパターン / Head First Design Patterns</title><link>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/</link><pubDate>Sat, 24 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/</guid><description>以下の書籍を読み，その内容をまとめる． 項目 内容 著者 Eric Freeman, Elisabeth Robson 監訳者 佐藤 直生 訳 木下 哲也 題 Head Firstデザインパターン 第2版 原題 Head First Design Patterns, 2nd Edition 発行 オ</description><content>&lt;p>以下の書籍を読み，その内容をまとめる．&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>項目&lt;/th>
&lt;th>内容&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>著者&lt;/td>
&lt;td>Eric Freeman, Elisabeth Robson&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>監訳者&lt;/td>
&lt;td>佐藤 直生&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>訳&lt;/td>
&lt;td>木下 哲也&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>題&lt;/td>
&lt;td>Head Firstデザインパターン 第2版&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>原題&lt;/td>
&lt;td>Head First Design Patterns, 2nd Edition&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>発行&lt;/td>
&lt;td>オライリージャパン&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>出版年月&lt;/td>
&lt;td>2022年06月&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ISBN&lt;/td>
&lt;td>978-4-87311-976-2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>URL&lt;/td>
&lt;td>&lt;a href="https://www.oreilly.co.jp/books/9784873119762/">発行元 Web サイト&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></content></item><item><title>オブジェクトを事情通に / Keeping your objects in the know</title><link>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/02_keeping_your_objects_in_the_know/</link><pubDate>Sat, 24 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/02_keeping_your_objects_in_the_know/</guid><description/><content/></item><item><title>唯一のオブジェクト / One of a king object</title><link>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/05_one_of_a_king_object/</link><pubDate>Sat, 24 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/05_one_of_a_king_object/</guid><description>Singleton Pattern インスタンスを 1 つしか必要としないオブジェクトは存在し，そのケースで複数のインスタンスを生成すると問題になるケースが存在する． Thread pool Cache Dialogbox Logger</description><content>&lt;h2 id="singleton-pattern">Singleton Pattern&lt;/h2>
&lt;p>インスタンスを 1 つしか必要としないオブジェクトは存在し，そのケースで複数のインスタンスを生成すると問題になるケースが存在する．&lt;/p>
&lt;ul>
&lt;li>Thread pool&lt;/li>
&lt;li>Cache&lt;/li>
&lt;li>Dialogbox&lt;/li>
&lt;li>Logger&lt;/li>
&lt;li>etc.&lt;/li>
&lt;/ul>
&lt;p>Singleton Pattern はインスタンスを 1 つだけ生成する仕組みである．&lt;/p>
&lt;p>典型的にはコンストラクタを非公開，つまり private にすることで (外部から) 生成を禁ずる．&lt;/p>
&lt;details open>
&lt;summary>head_first_design_patterns/one_of_a_king_object/singleton.cpp&lt;/summary>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">// Copyright (c) 2023, Kumazawa (sparrow-blue)
&lt;/span>&lt;span style="color:#75715e">// This source code is licensed under the BSD 3-Clause License.
&lt;/span>&lt;span style="color:#75715e">// See https://github.com/sparrow-blue/blog/blob/main/LICENSE for details.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;memory&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Singleton&lt;/span> {
&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#75715e">// 外部からのインスタンス化を禁ずる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Singleton() {}
&lt;span style="color:#66d9ef">static&lt;/span> Singleton&lt;span style="color:#f92672">*&lt;/span> singleton_;
&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> Singleton&lt;span style="color:#f92672">*&lt;/span> GetInstance() {
&lt;span style="color:#75715e">// 内部からであればコンストラクタが呼べる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>singleton_) singleton_ &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Singleton();
&lt;span style="color:#66d9ef">return&lt;/span> singleton_;
}
&lt;span style="color:#75715e">// コピーコンストラクタなどは delete で禁止しなければならない．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Singleton(&lt;span style="color:#66d9ef">const&lt;/span> Singleton&lt;span style="color:#f92672">&amp;amp;&lt;/span> other) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Singleton&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
};
Singleton&lt;span style="color:#f92672">*&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>singleton_ &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#75715e">// コンストラクタが private なので外部からインスタンス化できない．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// auto singleton = new Singleton();
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// static なメンバ関数からのみインスタンス化できる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> singleton &lt;span style="color:#f92672">=&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>GetInstance();
}
&lt;/code>&lt;/pre>&lt;/div>
&lt;/details>
&lt;h2 id="感想">感想&lt;/h2>
&lt;p>Singleton の是非についてはだいぶ意見が割れているような気がする．はたから見ている限り，仕組みが単純で導入しやすいため安易に使われてしまうが，他のパターンに比べてデメリットが明確であることが多いのがその所以のように思う．&lt;/p>
&lt;p>この節 (おそらくこの書籍全体) を通して，正確さよりも分かりやすさを意識しているようで，しばしば (言いたいことはわかるが) 矛盾した記述が散見された．&lt;/p>
&lt;p>例えば P.170 に以下の記載がある．&lt;/p>
&lt;blockquote>
&lt;p>Singleton パターンでは，オブジェクトは必要になったときに初めて作成できるのだ．&lt;/p>
&lt;/blockquote>
&lt;p>一方で P.174 には以下の記載がある．&lt;/p>
&lt;blockquote>
&lt;p>どの時点でもインスタンスが 1 つしか存在しないことを保証する，Singleton パターンに基づいています．&lt;/p>
&lt;/blockquote>
&lt;p>前者の「必要になるまでオブジェクトが作成 (インスタンス化の意と理解している) されない」に対して後者は「いついかなる時も (つまり必要か否かによらず) 1 つのインスタンスが存在する」と述べている．&lt;/p>
&lt;p>(私の理解では) Singleton の本旨は後者が正しい．矛盾するかを厳密に詰めていけば使用する言語にもよってくるのだが，一般に矛盾していると解釈して差し支えないだろう．しかし Singleton Pattern を実装した結果，前者の性質を持つことが往々にしてあり，それ自体は知っていなければならないだろう．そうはいってもこの下りを厳密に説明することが本来の目的ではないのもわかる．このように必要な情報を (言葉を選ばずに言えば) 騙し騙し混ぜ込んでいるように感じた．&lt;/p></content></item></channel></rss>