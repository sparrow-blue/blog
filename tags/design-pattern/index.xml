<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design Pattern on Design and Implementation</title><link>https://sparrow-blue.github.io/blog/tags/design-pattern/</link><description>Recent content in Design Pattern on Design and Implementation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 24 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://sparrow-blue.github.io/blog/tags/design-pattern/index.xml" rel="self" type="application/rss+xml"/><item><title>Head Firstデザインパターン / Head First Design Patterns</title><link>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/</link><pubDate>Sat, 24 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/</guid><description>以下の書籍を読み，その内容をまとめる． 項目 内容 著者 Eric Freeman, Elisabeth Robson 監訳者 佐藤 直生 訳 木下 哲也 題 Head Firstデザインパターン 第2版 原題 Head First Design Patterns, 2nd Edition 発行 オ</description><content>&lt;p>以下の書籍を読み，その内容をまとめる．&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>項目&lt;/th>
&lt;th>内容&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>著者&lt;/td>
&lt;td>Eric Freeman, Elisabeth Robson&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>監訳者&lt;/td>
&lt;td>佐藤 直生&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>訳&lt;/td>
&lt;td>木下 哲也&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>題&lt;/td>
&lt;td>Head Firstデザインパターン 第2版&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>原題&lt;/td>
&lt;td>Head First Design Patterns, 2nd Edition&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>発行&lt;/td>
&lt;td>オライリージャパン&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>出版年月&lt;/td>
&lt;td>2022年06月&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ISBN&lt;/td>
&lt;td>978-4-87311-976-2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>URL&lt;/td>
&lt;td>&lt;a href="https://www.oreilly.co.jp/books/9784873119762/">発行元 Web サイト&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></content></item><item><title>アルゴリズムのカプセル化 / Encapsulating Algorithm</title><link>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/08_encapsulating_algorithms/</link><pubDate>Sat, 24 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/08_encapsulating_algorithms/</guid><description>Template Method Pattern 同じような処理の流れを踏むクラスが複数あったとして，Template Method Pattern は処理の流れを抽象化する． 本文中では例として以下の 2 つのクラス</description><content>&lt;h2 id="template-method-pattern">Template Method Pattern&lt;/h2>
&lt;p>同じような処理の流れを踏むクラスが複数あったとして，Template Method Pattern は処理の流れを抽象化する．&lt;/p>
&lt;p>本文中では例として以下の 2 つのクラスを考えている．&lt;/p>
&lt;ol>
&lt;li>コーヒーを淹れる&lt;/li>
&lt;li>紅茶を淹れる&lt;/li>
&lt;/ol>
&lt;p>それぞれ，大枠として以下の 4 つのステップを踏むという点で共通している．&lt;/p>
&lt;ol>
&lt;li>お湯を沸かす&lt;/li>
&lt;li>コーヒー/紅茶を抽出する&lt;/li>
&lt;li>カップに注ぐ&lt;/li>
&lt;li>コンディメントを淹れる&lt;/li>
&lt;/ol>
&lt;p>Template Method Pattern はこの一連の手続きの流れ自体を抽象化する．&lt;/p>
&lt;h3 id="template-method-pattern-の定義">Template Method Pattern の定義&lt;/h3>
&lt;p>本書では以下のように Template Method Pttern を定義している．&lt;/p>
&lt;blockquote>
&lt;p>Template Method パターンは，メソッド内でアルゴリズムの骨組みを定義し，一部の手順をサブクラスに委ねる．Template Method は，アルゴリズムの構造を変えることなく，アルゴリズムのある手順をサブクラスに再定義させる．&lt;/p>
&lt;/blockquote>
&lt;h3 id="caffeinebeverage-の実装">CaffeineBeverage の実装&lt;/h3>
&lt;p>本文中にある例をベースに Template Method Pattern の例を示す．&lt;/p>
&lt;details open>
&lt;summary>head_first_design_patterns/encapsulating_algorithm/caffeine_beverage.cpp&lt;/summary>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">// Copyright (c) 2023, Kumazawa (sparrow-blue)
&lt;/span>&lt;span style="color:#75715e">// This source code is licensed under the BSD 3-Clause License.
&lt;/span>&lt;span style="color:#75715e">// See https://github.com/sparrow-blue/blog/blob/main/LICENSE for details.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">/// @brief 飲み物を淹れるカップを表現する
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Cup&lt;/span> {};
&lt;span style="color:#75715e">/// @brief カフェインを含む飲み物を表現する
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CaffeineBeverage&lt;/span> {
&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#75715e">/// @brief 抽象化された手続き
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> Cup PrepareRecipe() &lt;span style="color:#66d9ef">final&lt;/span> {
&lt;span style="color:#75715e">// この部分が Template Method であり，それぞれの処理自体は具象クラスの実装に任せる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>BoilWater();
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Brew();
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>PourInCup();
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>AddCondiments();
&lt;span style="color:#66d9ef">return&lt;/span> cup_;
}
&lt;span style="color:#66d9ef">protected&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#75715e">/// @brief カップ
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Cup cup_;
&lt;span style="color:#75715e">/// @brief お湯を沸かす
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">BoilWater&lt;/span>() {}
&lt;span style="color:#75715e">/// @brief 淹れる
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Brew&lt;/span>() {}
&lt;span style="color:#75715e">/// @brief カップにそそぐ
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">PourInCup&lt;/span>() {}
&lt;span style="color:#75715e">/// @brief ミルクやレモンなどを添加する
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddCondiments&lt;/span>() {}
};
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Coffee&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> CaffeineBeverage {
&lt;span style="color:#66d9ef">protected&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Brew() { &lt;span style="color:#75715e">/* コーヒーを淹れる */&lt;/span>
}
&lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddCondiments&lt;/span>() { &lt;span style="color:#75715e">/* ミルクを入れる */&lt;/span>
}
};
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Tea&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> CaffeineBeverage {
&lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Brew&lt;/span>() { &lt;span style="color:#75715e">/* 紅茶を淹れる */&lt;/span>
}
&lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddCondiments&lt;/span>() { &lt;span style="color:#75715e">/* レモンを入れる */&lt;/span>
}
};
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {}
&lt;/code>&lt;/pre>&lt;/div>
&lt;/details>
&lt;h3 id="ハリウッドの原則--hollywood-principle">ハリウッドの原則 / Hollywood Principle&lt;/h3>
&lt;blockquote>
&lt;p>ハリウッドの原則&lt;br>
こちらを呼び出すな．こちらから呼び出す．&lt;br>
(Don&amp;rsquo;t call up, we&amp;rsquo;ll call you.)&lt;/p>
&lt;/blockquote>
&lt;p>Object Oriented Design におけるハリウッドの原則は，コンポーネント (典型的にはオブジェクト) 間の依存 (参照) 関係にルールを持たせようとするものである．OSI Reference Model や TCP/IP Protocol Suite の概念が類するといえるだろう．つまり上位のレイヤは下位のレイヤに依存するが，下位のレイヤは上位のレイヤに依存しない関係である．&lt;/p>
&lt;p>Template Method Pattern の文脈でこの言葉が出てきたのは親クラスが呼び出し方を定義し，子クラスが呼び出される処理を実装する，という意味で子クラスはハリウッドの原則でいうところの呼び出される側に徹している，という意味合いであると思われる．&lt;/p>
&lt;p>高水準コンポーネントと低水準コンポーネントについては 4 章 (P.139) で説明されているので，引用しておく．&lt;/p>
&lt;blockquote>
&lt;p>「高水準」コンポーネントとは，他の「低水準」コンポーネントに対して定義された振る舞いを持つクラスのことです．&lt;/p>
&lt;/blockquote>
&lt;p>なお，ハリウッドの原則と依存関係反転の原則の関係性について述べられている (P.300) が，依存関係反転の原則については 4 章で説明されているとのことなので，ここでは言及しない．&lt;br>
// 章立ての順で読んでいないため，8 章についてのまとめを書いている今現在，また 4 章を読んでいない．&lt;/p>
&lt;h2 id="感想">感想&lt;/h2>
&lt;h3 id="abstract-method-と-hhok">Abstract Method と Hhok&lt;/h3>
&lt;p>本文中では Template Method Pattern の実現方法として抽象メソッドを具象クラスで実装する方式とフックするメソッドをオーバライドする方式の 2 種類を提示している．ただ，Temmplate Method Pattern の定義にもあるように Template Method Pattern の目的は「アルゴリズムの骨組みを定義」することにあると考える．&lt;/p>
&lt;h3 id="hollywood-principle-について">Hollywood Principle について&lt;/h3>
&lt;p>ハリウッドの原則について以下のように補足されている (P.298).&lt;/p>
&lt;blockquote>
&lt;p>ハリウッドの原則を使うと，低水準コンポーネントがそれ自体をシステムにフックすることはできますが，高水準コンポーネントが低水準コンポーネントがいつどのように必要になるかについて判断します．&lt;/p>
&lt;/blockquote>
&lt;p>個人的には (確かに親クラスと読んだりはするが) 基底クラスを高水準コンポーネントと呼び，派生クラスを低水準コンポーネントの呼ぶのは，なんとなく抵抗がある (派生クラスのほうがレイヤが上ではないか)．&lt;br>
// 確かに派生クラスが基底クラスに依存しているので，基底クラスが高水準コンポーネント (依存される側) で派生クラスが低水準コンポーネント (依存する側) である，と言っているというのはわかる．&lt;/p></content></item><item><title>オブジェクトを事情通に / Keeping your objects in the know</title><link>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/02_keeping_your_objects_in_the_know/</link><pubDate>Sat, 24 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/02_keeping_your_objects_in_the_know/</guid><description/><content/></item><item><title>唯一のオブジェクト / One of a king object</title><link>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/05_one_of_a_king_object/</link><pubDate>Sat, 24 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/05_one_of_a_king_object/</guid><description>Singleton Pattern インスタンスを 1 つしか必要としないオブジェクトが存在する．その場合，複数のインスタンスを生成するとかえって問題になることがある． Thread pool Cache Dialogbox</description><content>&lt;h2 id="hahahugoshortcode-s0-hbhb">Singleton Pattern&lt;/h2>
&lt;p>インスタンスを 1 つしか必要としないオブジェクトが存在する．その場合，複数のインスタンスを生成するとかえって問題になることがある．&lt;/p>
&lt;ul>
&lt;li>Thread pool&lt;/li>
&lt;li>Cache&lt;/li>
&lt;li>Dialogbox&lt;/li>
&lt;li>Logger&lt;/li>
&lt;li>etc.&lt;/li>
&lt;/ul>
&lt;p>Singleton Pattern はインスタンスが 1 度だけ生成されることを保証する仕組みである．&lt;/p>
&lt;p>典型的にはコンストラクタを非公開，つまり private にすることで (外部から) 生成を禁ずる．&lt;/p>
&lt;details open>
&lt;summary>head_first_design_patterns/one_of_a_king_object/singleton.cpp&lt;/summary>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">// Copyright (c) 2023, Kumazawa (sparrow-blue)
&lt;/span>&lt;span style="color:#75715e">// This source code is licensed under the BSD 3-Clause License.
&lt;/span>&lt;span style="color:#75715e">// See https://github.com/sparrow-blue/blog/blob/main/LICENSE for details.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;memory&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Singleton&lt;/span> {
&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#75715e">// 外部からのインスタンス化を禁ずる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Singleton() {}
&lt;span style="color:#66d9ef">static&lt;/span> Singleton&lt;span style="color:#f92672">*&lt;/span> singleton_;
&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> Singleton&lt;span style="color:#f92672">*&lt;/span> GetInstance() {
&lt;span style="color:#75715e">// 内部からであればコンストラクタが呼べる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>singleton_) singleton_ &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Singleton();
&lt;span style="color:#66d9ef">return&lt;/span> singleton_;
}
&lt;span style="color:#75715e">// コピーコンストラクタなどは delete で禁止しなければならない．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Singleton(&lt;span style="color:#66d9ef">const&lt;/span> Singleton&lt;span style="color:#f92672">&amp;amp;&lt;/span> other) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Singleton&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
};
Singleton&lt;span style="color:#f92672">*&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>singleton_ &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#75715e">// コンストラクタが private なので外部からインスタンス化できない．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// auto singleton = new Singleton();
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// static なメンバ関数からのみインスタンス化できる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> singleton &lt;span style="color:#f92672">=&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>GetInstance();
}
&lt;/code>&lt;/pre>&lt;/div>
&lt;/details>
&lt;h3 id="hahahugoshortcode-s2-hbhb">Singleton Pattern の定義&lt;/h3>
&lt;p>本書において Singleton Pattern を以下のように定義されている (P.177)．&lt;/p>
&lt;blockquote>
&lt;p>Singleton パターンは，クラスがインスタンスを 1 つしか持たないことを保証し，そのインスタンスにアクセスするグローバルポイントを提供する．&lt;/p>
&lt;/blockquote>
&lt;p>本文中では「グローバル」という言葉に対する定義はなされていないが，ここでいうグローバルは「あるプロセスの中」と解釈して差し支えないと思われる．しかし必ずしもプロセスである必要はないだろう．&lt;br>
// 極端なことをいえば Singleton Pattern の概念自体は現実世界に拡張できるだろう．&lt;/p>
&lt;p>現実的には，そのオブジェクトの定義およびインスタンスにアクセスしうる範囲をグローバル呼ぶものと想像する．前者は生成の可否，後者は複製の可否に影響する．例えば C# において &lt;code>internal class Singleton {}&lt;/code> のような形で定義されるとき，ここでいうグローバルはプロセスとは一致しない Singleton Pattern のクラスが定義されるだろう．&lt;/p>
&lt;h3 id="hahahugoshortcode-s3-hbhb">Thread-safe な実装&lt;/h3>
&lt;p>本文中でも指摘されているが &lt;code>GetInstance()&lt;/code> が Thread-unsafe なため Multi-thread Programming の文脈ではインスタンスが単一であることを保証できない．&lt;/p>
&lt;p>この問題に対する解決策を述べる．&lt;/p>
&lt;ol>
&lt;li>&lt;code>GetInsntance()&lt;/code> への同時アクセスを許容しない
&lt;ul>
&lt;li>言語によって実装は異なるが本書では Java を扱っているので synchronized 修飾子を例に挙げている&lt;/li>
&lt;li>C++ では &lt;code>std::mutex&lt;/code> で排他処理を行うことになるだろう&lt;/li>
&lt;li>同期処理はパフォーマンスへの影響が大きくなるため，頻繁に呼ばれるような処理ではなるべく避けたい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>遅延インスタンス生成から先行インスタンス生成に変える
&lt;ul>
&lt;li>書籍中では &lt;code>GetInstance()&lt;/code> が呼ばれたタイミングでインスタンス化される (遅延インスタンス生成) が Singleton Pattern のメリットであるかのように述べられている (詳細については感想で述べる) が，実際は生成するタイミング自体は Singleton Pattern の関知する所ではない ([Singleton Pattern の定義](#Singleton Pattern の定義) を参照)，&lt;/li>
&lt;li>端的にいえば &lt;code>GetInstance()&lt;/code> を呼ばれたタイミングではなく (static 初期化子などで) クラスがロードされたタイミングで初期化してしまえばよい．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ダブルチェックロッキングを利用し同期処理を減らす
&lt;ul>
&lt;li>&lt;code>GetInsntance()&lt;/code> の中でもコンストラクタの呼び出し部分にだけ同期処理を行い，大抵のケースでロックを取らずに済ませる実装である&lt;/li>
&lt;li>ここまでくると Singleton がどう，というよりは Multi-thread Programming におけるテクニックの話になってくるのでここでは割愛する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>以下は C++ で先行インスタンス生成のスタイルに変更したものである．
&lt;details open>
&lt;summary>head_first_design_patterns/one_of_a_king_object/singleton_static_initializer.cpp&lt;/summary>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">// Copyright (c) 2023, Kumazawa (sparrow-blue)
&lt;/span>&lt;span style="color:#75715e">// This source code is licensed under the BSD 3-Clause License.
&lt;/span>&lt;span style="color:#75715e">// See https://github.com/sparrow-blue/blog/blob/main/LICENSE for details.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;memory&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Singleton&lt;/span> {
&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#75715e">// 外部からのインスタンス化を禁ずる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Singleton() {}
&lt;span style="color:#66d9ef">static&lt;/span> Singleton&lt;span style="color:#f92672">*&lt;/span> singleton_;
&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> Singleton&lt;span style="color:#f92672">*&lt;/span> GetInstance() {
&lt;span style="color:#75715e">// 起動時に初期化されているため null check が不要である．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> singleton_;
}
&lt;span style="color:#75715e">// コピーコンストラクタなどは delete で禁止しなければならない．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Singleton(&lt;span style="color:#66d9ef">const&lt;/span> Singleton&lt;span style="color:#f92672">&amp;amp;&lt;/span> other) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Singleton&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
};
&lt;span style="color:#75715e">// null でなくインスタンスで初期化する．
&lt;/span>&lt;span style="color:#75715e">&lt;/span>Singleton&lt;span style="color:#f92672">*&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>singleton_ &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Singleton();
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#75715e">// コンストラクタが private なので外部からインスタンス化できない．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// auto singleton = new Singleton();
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// static なメンバ関数からのみインスタンス化できる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> singleton &lt;span style="color:#f92672">=&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>GetInstance();
}
&lt;/code>&lt;/pre>&lt;/div>
&lt;/details>
&lt;/p>
&lt;h3 id="hahahugoshortcode-s6-hbhb">Singleton Pattern の課題&lt;/h3>
&lt;p>Singleton Pattern と疎結合設計について以下のように記述されている (P.184)．&lt;/p>
&lt;blockquote>
&lt;p>疎結合原則は，「相互にやり取りするオブジェクト間は，疎結合設計を使用する」というものです．Singleton を変更する場合には，その Singleton に結びついたすべてのオブジェクトを変更しなければいけないので，Singleton ではこの原則に違反しやすいのです．&lt;/p>
&lt;/blockquote>
&lt;p>あるクラス A と クラス B が存在し，クラス B がクラス A を利用する場合，クラス B はクラス A に依存することになる．グローバルにアクセスされる Singleton クラスは様々なクラスから利用される．つまり依存されることになり，結合が密になる (疎結合原則に反する)．&lt;/p>
&lt;h2 id="hahahugoshortcode-s7-hbhb">感想&lt;/h2>
&lt;h3 id="正確さと分かりやすいさのトレードオフ">正確さと分かりやすいさのトレードオフ&lt;/h3>
&lt;p>一般に Singleton の是非はだいぶ意見が割れているように思う．はたから見ている限り，仕組みが単純で導入しやすいため安易に使われてしまうが，他のパターンに比べてデメリットが明確であることが多いのがその所以のように思う．&lt;/p>
&lt;p>この節 (おそらくこの書籍全体) を通して，正確さよりも分かりやすさを意識しているようで，しばしば (言いたいことはわかるが) 矛盾した記述が散見された．&lt;/p>
&lt;p>例えば P.170 に以下の記載がある．&lt;/p>
&lt;blockquote>
&lt;p>Singleton パターンでは，オブジェクトは必要になったときに初めて作成できるのだ．&lt;/p>
&lt;/blockquote>
&lt;p>一方で P.174 には以下の記載がある．&lt;/p>
&lt;blockquote>
&lt;p>どの時点でもインスタンスが 1 つしか存在しないことを保証する，Singleton パターンに基づいています．&lt;/p>
&lt;/blockquote>
&lt;p>前者の「必要になるまでオブジェクトが作成 (インスタンス化の意と理解している) されない」に対して後者は「いついかなる時も (つまり必要か否かによらず) 1 つのインスタンスが存在する」と述べている．&lt;/p>
&lt;p>この 2 文は (使用する言語にもよってくるのだが) 一般に矛盾していると解釈して差し支えないだろう．(私の理解では) Singleton の本旨は後者が正しい．しかし Singleton Pattern を実装した結果，前者の性質を持つことは往々にしてあり，それ自体は知っていたほうがよいだろう．&lt;/p>
&lt;p>しかしこのくだりを細かく説明することが目的としているわけではない．このように情報を (言葉を選ばずに言えば) 騙し騙し混ぜ込んでいるように感じた．&lt;/p>
&lt;h3 id="遅延インスタンス化と先行インスタンス化の謎">遅延インスタンス化と先行インスタンス化の謎&lt;/h3>
&lt;p>「遅延インスタンス化と先行インスタンス化の問題がある」と述べられているが，結局これがどのような状況なのか説明が少ない．特に P.184 でグローバル変数と Singleton の違いについて以下のように説明している．&lt;/p>
&lt;blockquote>
&lt;p>Javaでは，グローバル変数は基本的にはオブジェクトに対するスタティックな参照です．この方法でグローバル変数を使う場合，欠点がいくつかあります．1 つは既に説明したように，遅延インスタンス化と先行インスタンス化の問題があることです．&lt;/p>
&lt;/blockquote>
&lt;p>ここで説明されているのは，おそらく単にグローバル変数として定義するとそのグローバル変数を初期化するタイミングがコントロールできない&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>という話だと想像しはするが，想像の域をでない．&lt;/p>
&lt;h3 id="列挙体が-singleton-の孕む諸問題を解決する謎">列挙体が Singleton の孕む諸問題を解決する謎&lt;/h3>
&lt;p>P.185 に以下の記述があるが，正直まるでわからない．Java の仕様だろうか．&lt;/p>
&lt;blockquote>
&lt;p>これまで説明してきた問題の多く (同期に関する心配，クラスローディング問題，リフレクション，シリアライズ/デシリアライズ問題) は，列挙型を使って Singleton を作成すればすべて解決できます．&lt;/p>
&lt;/blockquote>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>単に static な参照が遅延インスタンス化だとするなら P.181 の例にある static 初期化子による先行インスタンス生成というのと矛盾する．static 参照かどうかは遅延インスタンス化/先行インスタンス化と関係ない話だと考える．&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></content></item></channel></rss>