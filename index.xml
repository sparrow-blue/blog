<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design and Implementation</title><link>https://sparrow-blue.github.io/blog/</link><description>Recent content on Design and Implementation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 13 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://sparrow-blue.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Command Pattern</title><link>https://sparrow-blue.github.io/blog/posts/design_pattern/command_pattern/</link><pubDate>Tue, 13 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/design_pattern/command_pattern/</guid><description>このエントリの目指すところ 以下の観点で調査/検討する． どのようなシーンで使えるのか なぜそのシーンで使えるのか 必要に応じてプログラムに起こす．</description><content>&lt;h2 id="このエントリの目指すところ">このエントリの目指すところ&lt;/h2>
&lt;p>以下の観点で調査/検討する．&lt;/p>
&lt;ol>
&lt;li>どのようなシーンで使えるのか&lt;/li>
&lt;li>なぜそのシーンで使えるのか&lt;/li>
&lt;/ol>
&lt;p>必要に応じてプログラムに起こす．&lt;/p>
&lt;h2 id="調査">調査&lt;/h2>
&lt;h3 id="語られる像">語られる像&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://ja.wikipedia.org/wiki/Command_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Wikipedia - Command パターン&lt;/a>
&lt;blockquote>
&lt;p>リクエストのために必要な手続きとデータをCommandオブジェクトとしてカプセル化した上で取り回し[1]、必要に応じてExecute（実行）するパターンである。オブジェクトであることを生かして命令のキューイングやロギング、Undo等が可能になり[2]、Executeを分離したことで手続きと実行を疎結合にできる。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>&lt;a href="https://www.techscore.com/tech/DesignPattern/Command">TECHSCORE - 22. Commandパターン&lt;/a>
&lt;blockquote>
&lt;p>あるオブジェクトに対して要求を送るということは、そのオブジェクトのメソッドを呼び出すことと同じです。 そして、メソッドにどのような引数を渡すか、ということによって要求の内容は表現されます。さまざまな要求を送ろうとすると、引数の数や種類を増やさなければなりませんが、 それには限界があります。そこで要求自体をオブジェクトにしてしまい、そのオブジェクトを引数に渡すようにします。それがCommandパターンです。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>&lt;a href="https://zenn.dev/morinokami/books/learning-patterns-1/viewer/command-pattern">フロントエンドのデザインパターン - コマンドパターン&lt;/a>
&lt;blockquote>
&lt;p>コマンドパターン (command pattern) を用いると、あるタスクを実行するオブジェクトと、そのメソッドを呼び出すオブジェクトを切り離すことができことができます。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>&lt;a href="https://www.itsenka.com/contents/development/designpattern/command.html">IT専科 - Command パターン&lt;/a>
&lt;blockquote>
&lt;p>「Command」という英単語は、「命令」を意味します。
このパターンでは、1つもしくは複数の命令を1つのオブジェクトで表現(命令の詳細処理をカプセル化)します。また、命令をオブジェクトとして管理するため、その命令の履歴管理、UNDO(取消し)機能の実装等が容易に行えます。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h3 id="整理">整理&lt;/h3>
&lt;ol>
&lt;li>Command Pattern の典型的な用例として Undo/Redo が挙げられる&lt;/li>
&lt;li>手続き一式を隠ぺいし，オブジェクトとして取り扱えるようにする&lt;/li>
&lt;li>手続きがオブジェクトとして扱われることで，キューイングや呼び出し履歴の記録が可能になる&lt;/li>
&lt;li>ある手続きを定義したとして，それを実行する責務と分離される&lt;/li>
&lt;/ol>
&lt;h3 id="疑問">疑問&lt;/h3>
&lt;ol>
&lt;li>Redo はともかく Undo をどのように実現するのか
&lt;ul>
&lt;li>Command に対する入力と出力を保持しておくということか&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="要点">要点&lt;/h2>
&lt;h2 id="検討">検討&lt;/h2>
&lt;h3 id="どのようなシーンで使えるのか">どのようなシーンで使えるのか&lt;/h3>
&lt;h3 id="なぜそのシーンで使えるのか">なぜそのシーンで使えるのか&lt;/h3>
&lt;h2 id="実例">実例&lt;/h2>
&lt;h3 id="設計">設計&lt;/h3>
&lt;h3 id="実装">実装&lt;/h3>
&lt;p>#include &lt;!-- raw HTML omitted -->
#include &lt;!-- raw HTML omitted -->
#include &lt;!-- raw HTML omitted -->
#include &lt;!-- raw HTML omitted -->
#include &lt;!-- raw HTML omitted -->
#include &lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>namespace DesignPattern {
namespace CommandPattern {
/**&lt;/p>
&lt;ul>
&lt;li>描画される図形の抽象クラス
*/
class Diagram {
public:
Diagram() : height(0), width(0) {}
virtual ~Diagram() = 0;
int height;
int width;
std::string to_string() {
std::stringstream ss;
ss &amp;laquo; typeid(this).name() &amp;laquo; &amp;ldquo;: &amp;quot;
&amp;laquo; &amp;ldquo;(&amp;rdquo; &amp;laquo; this-&amp;gt;height &amp;laquo; &amp;ldquo;,&amp;rdquo; &amp;laquo; this-&amp;gt;width &amp;laquo; &amp;ldquo;)&amp;quot;;
return ss.str();
}
};
Diagram::~Diagram() {}&lt;/li>
&lt;/ul>
&lt;p>/**&lt;/p>
&lt;ul>
&lt;li>図形が描画されるキャンバス
*/
class Canvas {
public:
void AddDiagram(std::shared_ptr&lt;!-- raw HTML omitted --> diagram) {
this-&amp;gt;diagrams.push_back(diagram);
}
void dump() {
std::for_each(
this-&amp;gt;diagrams.begin(), this-&amp;gt;diagrams.end(),
[](auto diagram) { std::cout &amp;laquo; diagram-&amp;gt;to_string() &amp;laquo; std::endl; });
}&lt;/li>
&lt;/ul>
&lt;p>private:
std::vector&amp;lt;std::shared_ptr&lt;!-- raw HTML omitted -->&amp;gt; diagrams;
};&lt;/p>
&lt;p>/**&lt;/p>
&lt;ul>
&lt;li>線分を表現するクラス
*/
class Line : public Diagram {
public:
Line() { this-&amp;gt;width = 10; }
};&lt;/li>
&lt;/ul>
&lt;p>/**&lt;/p>
&lt;ul>
&lt;li>三角形を表現するクラス
*/
class Triangle : public Diagram {
public:
Triangle() {
this-&amp;gt;width = 10;
this-&amp;gt;height = 5;
}
};&lt;/li>
&lt;/ul>
&lt;p>/**&lt;/p>
&lt;ul>
&lt;li>コマンドの抽象クラス
*/
class Command {
public:
Command(std::shared_ptr&lt;a href="DesignPattern::CommandPattern::Canvas">DesignPattern::CommandPattern::Canvas&lt;/a> canvas_)
: canvas(canvas_) {}
virtual void Execute() = 0;&lt;/li>
&lt;/ul>
&lt;p>protected:
std::shared_ptr&lt;!-- raw HTML omitted --> canvas;
};&lt;/p>
&lt;p>/*&lt;/p>
&lt;ul>
&lt;li>線分の生成を担うコマンド
*/
class CreateLineDiagramCommand : public Command {
public:
CreateLineDiagramCommand(
std::shared_ptr&lt;a href="DesignPattern::CommandPattern::Canvas">DesignPattern::CommandPattern::Canvas&lt;/a> canvas_)
: Command(canvas_) {}
virtual void Execute() {
auto new_diagram = std::make_shared&lt;!-- raw HTML omitted -->();
this-&amp;gt;canvas-&amp;gt;AddDiagram(new_diagram);
}
};&lt;/li>
&lt;/ul>
&lt;p>/*&lt;/p>
&lt;ul>
&lt;li>三角形の生成を担うコマンド
*/
class CreateTriangleDiagramCommand : public Command {
public:
CreateTriangleDiagramCommand(
std::shared_ptr&lt;a href="DesignPattern::CommandPattern::Canvas">DesignPattern::CommandPattern::Canvas&lt;/a> canvas_)
: Command(canvas_) {
auto new_diagram = std::make_shared&lt;!-- raw HTML omitted -->();
this-&amp;gt;canvas-&amp;gt;AddDiagram(new_diagram);
}
virtual void Execute() {}
};&lt;/li>
&lt;/ul>
&lt;p>/*&lt;/p>
&lt;ul>
&lt;li>図形の移動を担うコマンド
*/
class MoveDiagramCommand : public Command {
public:
virtual void Execute() {}
};&lt;/li>
&lt;/ul>
&lt;p>/*&lt;/p>
&lt;ul>
&lt;li>図形のリサイズを担うコマンド
*/
class ResizeDiagramCommand : public Command {
public:
virtual void Execute() {}
};
} // namespace CommandPattern
} // namespace DesignPattern&lt;/li>
&lt;/ul>
&lt;p>using namespace DesignPattern::CommandPattern;
int main() {
auto canvas = std::make_shared&lt;!-- raw HTML omitted -->();
auto execution_queue = std::queue&amp;lt;std::shared_ptr&lt;!-- raw HTML omitted -->&amp;gt;();
auto execution_history = std::list&amp;lt;std::shared_ptr&lt;!-- raw HTML omitted -->&amp;gt;();&lt;/p>
&lt;p>std::cout &amp;laquo; &amp;ldquo;# initial state&amp;rdquo; &amp;laquo; std::endl;
canvas-&amp;gt;dump();&lt;/p>
&lt;p>execution_queue.push(std::make_shared&lt;!-- raw HTML omitted -->(canvas));
execution_queue.push(std::make_shared&lt;!-- raw HTML omitted -->(canvas));&lt;/p>
&lt;p>while (execution_queue.size()) {
auto command = execution_queue.front();
command-&amp;gt;Execute();
execution_history.push_back(command);
execution_queue.pop();
}&lt;/p>
&lt;p>std::cout &amp;laquo; &amp;ldquo;# final state&amp;rdquo; &amp;laquo; std::endl;
canvas-&amp;gt;dump();
}&lt;/p>
&lt;h3 id="実行結果">実行結果&lt;/h3>
&lt;pre>&lt;code>$ clang++ command_pattern.cpp -o command_pattern.out
$ ./command_pattern.out
# initial state
# final state
PN13DesignPattern14CommandPattern7DiagramE: (5,10)
PN13DesignPattern14CommandPattern7DiagramE: (0,10)
&lt;/code>&lt;/pre></content></item><item><title>ブログを書くことにした</title><link>https://sparrow-blue.github.io/blog/posts/2023-06-11/</link><pubDate>Tue, 13 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/2023-06-11/</guid><description>何年ぶりだろうか．学生の時分，そのころプレイしていた MMORPG に関するブログを書いていた記憶がある．それが最後に書いたブログだと思われるが，だとする</description><content>&lt;p>何年ぶりだろうか．学生の時分，そのころプレイしていた MMORPG に関するブログを書いていた記憶がある．それが最後に書いたブログだと思われるが，だとするとずいぶん昔の話である．&lt;/p>
&lt;p>これまでも気になったことを Twitter に書いてみたりしていたのだが，どうしても複数の投稿をまたぐ長文になってしまうし，そんなものはフォロワにとって興味のないものというのは想像の易く投稿に躊躇することがしばしばあった． とはいえ，考えたことを記録しておきたい場合もある．何らかの形で公開しようと試みることで考えが整理されることもあるだろう．&lt;/p>
&lt;p>そんな折に Hugo を使うと GitHub Pages でブログが作れるという話を風の便りに聞き，試してみることにした．自分の好きなエディタで記事が書けるというのは助かる．&lt;/p>
&lt;p>おそらく設計や開発の話になると思う．いわゆる技術ブログというものになるだろう．もしかしたら，はてなブログ，Qiita や Zenn がいいのかもしれない．しかし，もともとが Twitter の鍵垢で投稿しようとしていた内容を書く環境を作る，という目的だったことを考えると積極的に他者の目に触れる必要はない．積極的な理由ではないが GitHub Pages + Hugo でブログを書いてみようと思う．&lt;/p></content></item></channel></rss>