<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Head Firstデザインパターン / Head First Design Patterns on Design and Implementation</title><link>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/</link><description>Recent content in Head Firstデザインパターン / Head First Design Patterns on Design and Implementation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 24 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>オブジェクトを事情通に / Keeping your objects in the know</title><link>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/02_keeping_your_objects_in_the_know/</link><pubDate>Sat, 24 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/02_keeping_your_objects_in_the_know/</guid><description/><content/></item><item><title>唯一のオブジェクト / One of a king object</title><link>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/05_one_of_a_king_object/</link><pubDate>Sat, 24 Jun 2023 00:00:00 +0000</pubDate><guid>https://sparrow-blue.github.io/blog/posts/books/head_first_design_patterns/05_one_of_a_king_object/</guid><description>Singleton Pattern の定義 インスタンスを 1 つしか必要としないオブジェクトは存在し，そのケースで複数のインスタンスを生成すると問題になるケースが存在する． Thread pool</description><content>&lt;h2 id="hahahugoshortcode-s0-hbhb">Singleton Pattern の定義&lt;/h2>
&lt;p>インスタンスを 1 つしか必要としないオブジェクトは存在し，そのケースで複数のインスタンスを生成すると問題になるケースが存在する．&lt;/p>
&lt;ul>
&lt;li>Thread pool&lt;/li>
&lt;li>Cache&lt;/li>
&lt;li>Dialogbox&lt;/li>
&lt;li>Logger&lt;/li>
&lt;li>etc.&lt;/li>
&lt;/ul>
&lt;p>Singleton Pattern はインスタンスを 1 つだけ生成する仕組みである．&lt;/p>
&lt;p>典型的にはコンストラクタを非公開，つまり private にすることで (外部から) 生成を禁ずる．&lt;/p>
&lt;details open>
&lt;summary>head_first_design_patterns/one_of_a_king_object/singleton.cpp&lt;/summary>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">// Copyright (c) 2023, Kumazawa (sparrow-blue)
&lt;/span>&lt;span style="color:#75715e">// This source code is licensed under the BSD 3-Clause License.
&lt;/span>&lt;span style="color:#75715e">// See https://github.com/sparrow-blue/blog/blob/main/LICENSE for details.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;memory&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Singleton&lt;/span> {
&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#75715e">// 外部からのインスタンス化を禁ずる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Singleton() {}
&lt;span style="color:#66d9ef">static&lt;/span> Singleton&lt;span style="color:#f92672">*&lt;/span> singleton_;
&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> Singleton&lt;span style="color:#f92672">*&lt;/span> GetInstance() {
&lt;span style="color:#75715e">// 内部からであればコンストラクタが呼べる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>singleton_) singleton_ &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Singleton();
&lt;span style="color:#66d9ef">return&lt;/span> singleton_;
}
&lt;span style="color:#75715e">// コピーコンストラクタなどは delete で禁止しなければならない．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Singleton(&lt;span style="color:#66d9ef">const&lt;/span> Singleton&lt;span style="color:#f92672">&amp;amp;&lt;/span> other) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Singleton&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
};
Singleton&lt;span style="color:#f92672">*&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>singleton_ &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#75715e">// コンストラクタが private なので外部からインスタンス化できない．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// auto singleton = new Singleton();
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// static なメンバ関数からのみインスタンス化できる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> singleton &lt;span style="color:#f92672">=&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>GetInstance();
}
&lt;/code>&lt;/pre>&lt;/div>
&lt;/details>
&lt;h3 id="hahahugoshortcode-s2-hbhb">Singleton Pattern の定義&lt;/h3>
&lt;p>本書において Singleton Pattern を以下のように定義されている (P.177)．&lt;/p>
&lt;blockquote>
&lt;p>Singleton パターンは，クラスがインスタンスを 1 つしか持たないことを保証し，そのインスタンスにアクセスするグローバルポイントを提供する．&lt;/p>
&lt;/blockquote>
&lt;p>書籍内には「グローバル」という言葉に対する定義は記述されていないが，ここでいうグローバルは「あるプロセスの中」と解釈して差し支えないとは思うが必ずしもプロセスである必要はないだろう．&lt;br>
// 極端なことをいえば Singleton Pattern の概念自体は現実世界に拡張できるだろう．&lt;/p>
&lt;p>一方で現実的には，そのオブジェクトの定義およびインスタンスにアクセスしうる範囲をグローバル呼ぶものと想像する．前者は生成の可否，後者は複製の可否に影響する．例えば C# において &lt;code>internal class Singleton {}&lt;/code> のような形で定義されるとき，ここでいうグローバルはプロセスとは一致しない Singleton Pattern のクラスが定義されるだろう．&lt;/p>
&lt;h3 id="hahahugoshortcode-s3-hbhb">Thread-safe な実装&lt;/h3>
&lt;p>本書でも指摘されているが &lt;code>GetInstance()&lt;/code> が Thread-unsafe なため Multi-thread Programming の文脈ではインスタンスが単一であることを保証できない．&lt;/p>
&lt;p>この問題に対する解決策を述べる．&lt;/p>
&lt;ol>
&lt;li>&lt;code>GetInsntance()&lt;/code> への同時アクセスを許容しない
&lt;ul>
&lt;li>言語によって実装は異なるが本書では Java を扱っているので synchronized 修飾子を例に挙げている&lt;/li>
&lt;li>C++ では &lt;code>std::mutex&lt;/code> で排他処理を行うことになるだろう&lt;/li>
&lt;li>同期処理はパフォーマンスへの影響が大きくなるため，頻繁に呼ばれるような処理ではなるべく避けたい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>遅延インスタンス生成から先行インスタンス生成に変える
&lt;ul>
&lt;li>書籍中では &lt;code>GetInstance()&lt;/code> が呼ばれたタイミングでインスタンス化される (遅延インスタンス生成) が Singleton Pattern のメリットであるかのように述べられている (詳細については感想で述べる) が，実際は生成するタイミング自体は Singleton Pattern の関知する所ではない ([Singleton Pattern の定義](#Singleton Pattern の定義) を参照)，&lt;/li>
&lt;li>端的にいえば &lt;code>GetInstance()&lt;/code> を呼ばれたタイミングではなく (static 初期化子などで) クラスがロードされたタイミングで初期化してしまえばよい．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ダブルチェックロッキングを利用し同期処理を減らす
&lt;ul>
&lt;li>&lt;code>GetInsntance()&lt;/code> の中でもコンストラクタの呼び出し部分にだけ同期処理を行い，大抵のケースでロックを取らずに済ませる実装である&lt;/li>
&lt;li>ここまでくると Singleton がどう，というよりは Multi-thread Programming におけるテクニックの話になってくるのでここでは割愛する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>以下は C++ で先行インスタンス生成のスタイルに変更したものである．
&lt;details open>
&lt;summary>head_first_design_patterns/one_of_a_king_object/singleton_static_initializer.cpp&lt;/summary>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">// Copyright (c) 2023, Kumazawa (sparrow-blue)
&lt;/span>&lt;span style="color:#75715e">// This source code is licensed under the BSD 3-Clause License.
&lt;/span>&lt;span style="color:#75715e">// See https://github.com/sparrow-blue/blog/blob/main/LICENSE for details.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;memory&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Singleton&lt;/span> {
&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#75715e">// 外部からのインスタンス化を禁ずる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Singleton() {}
&lt;span style="color:#66d9ef">static&lt;/span> Singleton&lt;span style="color:#f92672">*&lt;/span> singleton_;
&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> Singleton&lt;span style="color:#f92672">*&lt;/span> GetInstance() {
&lt;span style="color:#75715e">// 起動時に初期化されているため null check が不要である．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> singleton_;
}
&lt;span style="color:#75715e">// コピーコンストラクタなどは delete で禁止しなければならない．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Singleton(&lt;span style="color:#66d9ef">const&lt;/span> Singleton&lt;span style="color:#f92672">&amp;amp;&lt;/span> other) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Singleton&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
};
&lt;span style="color:#75715e">// null でなくインスタンスで初期化する．
&lt;/span>&lt;span style="color:#75715e">&lt;/span>Singleton&lt;span style="color:#f92672">*&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>singleton_ &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Singleton();
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#75715e">// コンストラクタが private なので外部からインスタンス化できない．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// auto singleton = new Singleton();
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// static なメンバ関数からのみインスタンス化できる．
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> singleton &lt;span style="color:#f92672">=&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>GetInstance();
}
&lt;/code>&lt;/pre>&lt;/div>
&lt;/details>
&lt;/p>
&lt;h3 id="hahahugoshortcode-s6-hbhb">Singleton Pattern の課題&lt;/h3>
&lt;p>Singleton Pattenr と疎結合設計について以下のように記述されている (P.184)．&lt;/p>
&lt;blockquote>
&lt;p>疎結合原則は，「相互にやり取りするオブジェクト間は，疎結合設計を使用する」というものです．Singleton を変更する場合には，その Singleton に結びついたすべてのオブジェクトを変更しなければいけないので，Singleton ではこの原則に違反しやすいのです．&lt;/p>
&lt;/blockquote>
&lt;h2 id="hahahugoshortcode-s7-hbhb">感想&lt;/h2>
&lt;h3 id="正確さと分かりやすいさのトレードオフ">正確さと分かりやすいさのトレードオフ&lt;/h3>
&lt;p>一般に Singleton の是非についてはだいぶ意見が割れているような気がする．はたから見ている限り，仕組みが単純で導入しやすいため安易に使われてしまうが，他のパターンに比べてデメリットが明確であることが多いのがその所以のように思う．&lt;/p>
&lt;p>この節 (おそらくこの書籍全体) を通して，正確さよりも分かりやすさを意識しているようで，しばしば (言いたいことはわかるが) 矛盾した記述が散見された．&lt;/p>
&lt;p>例えば P.170 に以下の記載がある．&lt;/p>
&lt;blockquote>
&lt;p>Singleton パターンでは，オブジェクトは必要になったときに初めて作成できるのだ．&lt;/p>
&lt;/blockquote>
&lt;p>一方で P.174 には以下の記載がある．&lt;/p>
&lt;blockquote>
&lt;p>どの時点でもインスタンスが 1 つしか存在しないことを保証する，Singleton パターンに基づいています．&lt;/p>
&lt;/blockquote>
&lt;p>前者の「必要になるまでオブジェクトが作成 (インスタンス化の意と理解している) されない」に対して後者は「いついかなる時も (つまり必要か否かによらず) 1 つのインスタンスが存在する」と述べている．&lt;/p>
&lt;p>(私の理解では) Singleton の本旨は後者が正しい．矛盾するかを厳密に詰めていけば使用する言語にもよってくるのだが，一般に矛盾していると解釈して差し支えないだろう．しかし Singleton Pattern を実装した結果，前者の性質を持つことが往々にしてあり，それ自体は知っていなければならないだろう．そうはいってもこの下りを厳密に説明することが本来の目的ではないのもわかる．このように必要な情報を (言葉を選ばずに言えば) 騙し騙し混ぜ込んでいるように感じた．&lt;/p>
&lt;h3 id="遅延インスタンス化と先行インスタンス化の謎">遅延インスタンス化と先行インスタンス化の謎&lt;/h3>
&lt;p>「遅延インスタンス化と先行インスタンス化の問題がある」と述べられているが，結局これがどのような状況なのか説明が少ない．特に P.184 でグローバル変数と Singleton の違いについて以下のように説明している．&lt;/p>
&lt;blockquote>
&lt;p>Javaでは，グローバル変数は基本的にはオブジェクトに対するスタティックな参照です．この方法でグローバル変数を使う場合，欠点がいくつかあります．1 つは既に説明したように，遅延インスタンス化と先行インスタンス化の問題があることです．&lt;/p>
&lt;/blockquote>
&lt;p>ここで説明されているのは，おそらく単にグローバル変数として定義するとそのグローバル変数を初期化するタイミングがコントロールできない&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>という話だと想像しはするが，想像の域をでない．&lt;/p>
&lt;h3 id="列挙体が-singleton-の孕む諸問題を解決する謎">列挙体が Singleton の孕む諸問題を解決する謎&lt;/h3>
&lt;p>P.185 に以下の記述があるが，正直まるでわからない．Java の仕様だろうか．&lt;/p>
&lt;blockquote>
&lt;p>これまで説明してきた問題の多く (同期に関する心配，クラスローディング問題，リフレクション，シリアライズ/デシリアライズ問題) は，列挙型を使って Singleton を作成すればすべて解決できます．&lt;/p>
&lt;/blockquote>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>単に static な参照が遅延インスタンス化だとするなら P.181 の例にある static 初期化子による先行インスタンス生成というのと矛盾する．static 参照かどうかは遅延インスタンス化/先行インスタンス化と関係ない話だと考える．&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></content></item></channel></rss>